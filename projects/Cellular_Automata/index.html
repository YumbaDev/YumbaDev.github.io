<!DOCTYPE html>
<html>
<head>
	<title>Cellular Automata</title>
	<style>
		:root {
			--input-bg-color: #cfc8c0;
			--solid-color: #bab0a4;
			--air-color: #e4e0dc;
			--background-color: #e4e0dc;

			--border-color: #e4e0dc;

			--text-color: #000000;
			--blue-color: #007bff;
			--gray-color: #6c757d;
			--green-color: #28a745;
			--red-color: #dc3545;
			--yellow-color: #ffc107;
			--info-color: #17a2b8;
			--light-color: #f8f9fa;
			--dark-color: #343a40;
			--link-color: #007bff;
			--link-hover-color: #0056b3;
		}

		body {
			background-color: var(--background-color);
		}
		
        #container {
            display: flex;
        }
        
        #inputs {	
            flex-basis: 25%;
			padding: 10px;
            margin-right: 20px;
			background-color: var(--input-bg-color);
			display: block;
			overflow: auto;
        }
        
        #results {
            flex-basis: 75%;
			margin-right: 10px;
			max-height: 50vh;
        }

        table {
			border-collapse: collapse;
		}
        
        #generate-btn {
            margin-top: 10px;
            margin-right: 16px;
            width: 50%;
			background-color: var(--green-color);
			color: var(--light-color);
			border: none;
			border-radius: 5px;
			padding: 5px;
			cursor: pointer;
		}
		
		#generate-btn:hover {
			background-color: var(--gray-color);
		}
		
		#step-btn {
			margin-top: 10px;
            width: 50%;
			background-color: var(--blue-color);
			color: var(--light-color);
			border: none;
			border-radius: 5px;
			padding: 5px;
			cursor: pointer;
		}
		
		#step-btn:hover {
			background-color: var(--gray-color);
		}

		#invert-btn {
			margin-bottom: 16px;
		}
        
        #main-btn-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

		.input-container label {
			display: inline-block;
			vertical-align: middle;
			margin-right: 5px;
			white-space: nowrap;
		}

        .checkbox-container {
            margin-bottom: 10px;
        }

        .checkbox-container label {
            display: inline-block;
            vertical-align: middle;
            margin-right: 5px;
        }

        .checkbox-container input[type="checkbox"] {
            display: inline-block;
            vertical-align: middle;
        }

		td {
			height: 20px;
			width: 20px;
			text-align: center;
			vertical-align: middle;
			background-color: var(--air-color);
			color: var(--text-color);
			font-size: 14px;
			font-weight: bold;
		}

		.solid {
			background-color: var(--solid-color);
		}

		.air {
			background-color: var(--air-color);
		}

		.input-container {
			display: flex;
			margin-bottom: 10px;
			flex-direction: column;
			max-width: 25%;
		}

		.btn-grid-container{
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			grid-gap: 5px;
			padding: 0;
			margin: 0;
			overflow: hidden;
		}

		.small-btn{
			width: 100%;
			height: 35px;
		}

		.custom-steps-container{
			margin-bottom: 20px;
		}

		#numSteps{
			width: 25%;
		}

		#numStepsBtn{
			width: 25%;
			float: right;
		}

	</style>
</head>
<body>
    <div id="container">
        <div id="inputs">
			<h2>Cellular Automata</h1>

			<label for="numRows"># of Rows:</label>
            <div class="input-container">
                <input type="number" id="numRows" name="numRows" value="32" min="16" max="96">
            </div>

			<label for="numCols"># of Columns:</label>
            <div class="input-container">
                <input type="number" id="numCols" name="numCols" value="32" min="16" max="96">
            </div>

			<label for="probZero">NonSolid Probability (Default: 0.6)</label>
            <div class="input-container">
                <input type="number" id="probZero" name="probZero" value="0.6" step="0.1" min="0" max="1">
            </div>

			<label for="numToTurnSolid"># of Neighbors to turn Solid (Default: 4):</label>
			<div class="input-container">
                <input type="number" id="numToTurnSolid" name="numToTurnSolid" value="4" min="1" max="8">
            </div>

			<label for="numToTurnNonSolid"># of Neighbors to turn NonSolid (Default: 3):</label>
			<div class="input-container">
                <input type="number" id="numToTurnNonSolid" name="numToTurnNonSolid" value="3" min="1" max="8">
            </div>



            <div id="main-btn-container">
                <button id="generate-btn" onclick="generateGrid()">Generate New</button>
                <button id="step-btn" onclick="performStep()">Perform Step</button>
            </div>

			<label for="numSteps">Perform Given # of Steps (Default: 5):</label>
			<div class="custom-steps-container">
                <input type="number" id="numSteps" name="numSteps" value="5" min="1" max="10">
				<input type="button" value=" Go " id="numStepsBtn" onclick="customNumSteps()" >
            </div>


			<div class="btn-grid-container">
				<div class="btn-grid-item">
					<button id="max-step-btn" onclick="maxStep()" class="small-btn">Perform Max steps</button>
				</div>
				<div class="btn-grid-item">
					<button id="revert-btn" onclick="revertOriginal()" class="small-btn">Revert to Original</button>
				</div>
				<div class="btn-grid-item">
					<button id="undo-btn" onclick="revertStep()" class="small-btn">Revert step</button>
				</div>
				<div class="btn-grid-item">
					<button id="invert-btn" onclick="invertGrid()" class="small-btn">Invert Grid</button>
				</div>
			</div>

            <div class="checkbox-container">
                <label for="other-checkbox">Show Grid Border:</label>
                <input type="checkbox" id="toggle-checkbox" onclick="toggleBorder()">
            </div>


        </div>

        <div id="results">
            <table id="grid"></table>
        </div>
    </div>

	<script>

		let cells = [];
		let original_cells = cells;
		let cells_history = [];
		let hasBorder = false;
		let finishedSteps = false;

	
		function generateGrid() {
			finishedSteps = false;

			let numRows = parseInt(document.getElementById("numRows").value);
			let numCols = parseInt(document.getElementById("numCols").value);
			let probZero = parseFloat(document.getElementById("probZero").value);

			if(numRows <= 0 || numCols <= 0){
				alert("Cannot Generate grid will given Rows/Cols")
				return;
			}

			cells = [];
			original_cells = [];
			cells_history = [];

			let grid = document.getElementById("grid");
			grid.innerHTML = "";

			let baseSize = 20;

			// Get the maximum number of cells that can fit within the grid without scrolling
			let containerWidth = document.getElementById("results").clientWidth;
			let containerHeight = document.getElementById("results").clientHeight;
			let maxNumCols = Math.floor(containerWidth / baseSize); // Assuming each cell has a width of 20px
			let maxNumRows = Math.floor(containerHeight / baseSize); // Assuming each cell has a height of 20px
			let cellSize = Math.min(containerWidth / numCols, containerHeight / numRows, baseSize);

			// Generate the grid
			for (let i = 0; i < numRows; i++) {
				cells.push([]);
				let row = "<tr>";

				for (let j = 0; j < numCols; j++) {

					let cellClass = "solid";

					if(i > 0 && i < numRows-1 && j > 0 && j < numCols-1){
						cellClass = Math.random() < probZero ? "air" : "solid";
					}

					let cellValue = cellClass === "solid" ? 1 : 0;
					
					cells[i].push(cellValue);
					
					row += `<td class="${cellClass}" style="width: ${cellSize}px; height: ${cellSize}px;`;
					if(hasBorder) row += `border: 1px solid var(--border-color);`;
					row += `"></td>`;
				}
				
				row += "</tr>";
				grid.innerHTML += row;
			}

			original_cells = cells;

			console.log("// Generated cells");
		}




		function updateGrid() {
			// Update the grid to show the changes
			let grid = document.getElementById("grid");
			let rows = grid.getElementsByTagName("tr");

			for (let i = 0; i < rows.length; i++) {
				let cellsInRow = rows[i].getElementsByTagName("td");
				for (let j = 0; j < cellsInRow.length; j++) {
					cellsInRow[j].className = cells[i][j] === 0 ? "air" : "solid";
				}
			}
		}




		function invertGrid() {
			// Iterate through each cell and invert its value
			for (let i = 0; i < cells.length; i++) {
				for (let j = 0; j < cells[i].length; j++) {
					cells[i][j] = cells[i][j] === 0 ? 1 : 0;
				}
			}
			updateGrid();
		}




		function toggleBorder() {
			hasBorder = !hasBorder;
			let cells = document.getElementsByTagName("td");
			for (let i = 0; i < cells.length; i++) {
				if (hasBorder) {
					cells[i].style.border = "1px solid var(--border-color)";
				} else {
					cells[i].style.border = "";
				}
			}
		}



		function countSolidNeighbors(row, col) {
			let count = 0;
			for (let i = -1; i <= 1; i++) {
				for (let j = -1; j <= 1; j++) {
				// Skip checking the cell itself
				if (i === 0 && j === 0) continue;

				// Check if neighbor cell is within bounds
				let neighborRow = row + i;
				let neighborCol = col + j;
				if (neighborRow < 0 || neighborCol < 0 || neighborRow >= cells.length || neighborCol >= cells[0].length) {
					continue;
				}

				// Count solid neighbors
				if (cells[neighborRow][neighborCol] === 1) {
					count++;
				}
				}
			}
			return count;
		}




		function performStep(doMaxStep) {
			if(cells === undefined || cells.length == 0){
				alert("Generate New first!")
				return;
			}

			let numToTurnSolid = parseInt(document.getElementById("numToTurnSolid").value);
			let numToTurnNonSolid = parseInt(document.getElementById("numToTurnNonSolid").value);

			let numRows = cells.length;
			let numCols = cells[0].length;
			let newCells = [];

			let updatedCells = false;

			for (let i = 0; i < numRows; i++) {
				newCells[i] = [];
				for (let j = 0; j < numCols; j++) {
					if(i > 0 && i < numRows-1 && j > 0 && j < numCols-1){
						let numSolidNeighbors = countSolidNeighbors(i, j);
						if (cells[i][j] === 1) { // solid cell
							if (numSolidNeighbors < numToTurnNonSolid) {
								// cell dies due to underpopulation or overpopulation
								newCells[i][j] = 0;
								updatedCells = true;
							} else {
								// cell survives
								newCells[i][j] = 1;
							}
						} else { // nonsolid cell
							if (numSolidNeighbors > numToTurnSolid) {
								// cell becomes solid due to reproduction
								newCells[i][j] = 1;
								updatedCells = true;
							} else {
								// cell remains nonsolid
								newCells[i][j] = 0;
							}
						}
					} else {
						newCells[i][j] = 1;
					}
				}
			}

			if (updatedCells){
				cells_history.push(cells);
				cells = newCells;
				updateGrid();
				console.log("// Performed step");
				finishedSteps = false;
			} else {
				if(!doMaxStep) alert("Cannot step further");
				finishedSteps = true;
			}		
			
			return finishedSteps;
		}



		function revertOriginal(){
			cells = original_cells;
			cells_history = [];
			finishedSteps = false;
			updateGrid();

			console.log("// Reverted to original cells")
		}


		function revertStep(){

				if(cells_history === undefined || cells_history.length === 0){
					console.log("// ERR: Cell history is undefined");
					return;
				}

				cells = cells_history.pop();
				finishedSteps = false;
				updateGrid();

				console.log("// Went back a step")
			
		}

		function customNumSteps(){
			let numSteps = parseInt(document.getElementById("numSteps").value);

			while(numSteps--){
				console.log(numSteps);
				performStep(true);
			}
		}

		function maxStep(){
			if(cells === undefined || cells.length == 0){
				alert("Generate New first!")
				return;
			}

			if(finishedSteps){
				alert("Cannot step further");
			}

			while(!performStep(true)){}
		}

		function preset(){
			// CLASSIC Presert
			// 0.6, 4, 3, 5

			// SMOOTHER Presert
			// 0.6, 4, 3, 5
			// generate new
			// perform given # of steps 5
			// invert grid
			// perform given # of steps 5
			// invert grid
			// perform given # of steps 5

			// ISLAND PRESET
			// 0.5, 4, 4, 5

			// LARGE OPEN CAVE
			// 0.6, 4, 4, 5
		}

	</script>
</body>
</html>
